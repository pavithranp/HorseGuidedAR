// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Scan.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace ScanOut {

  /// <summary>Holder for reflection information generated from Scan.proto</summary>
  public static partial class ScanReflection {

    #region Descriptor
    /// <summary>File descriptor for Scan.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ScanReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgpTY2FuLnByb3RvEgdTY2FuT3V0IrsBCgRTY2FuEhEKCWFuZ2xlX21pbhgB",
            "IAEoARIRCglhbmdsZV9tYXgYAiABKAESFwoPYW5nbGVfaW5jcmVtZW50GAMg",
            "ASgBEhYKDnRpbWVfaW5jcmVtZW50GAQgASgBEhEKCXNjYW5fdGltZRgFIAEo",
            "ARIRCglyYW5nZV9taW4YBiABKAESEQoJcmFuZ2VfbWF4GAcgASgBEg4KBnJh",
            "bmdlcxgIIAMoARITCgtpbnRlbnNpdGllcxgJIAMoAUIKqgIHU2Nhbk91dGIG",
            "cHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::ScanOut.Scan), global::ScanOut.Scan.Parser, new[]{ "AngleMin", "AngleMax", "AngleIncrement", "TimeIncrement", "ScanTime", "RangeMin", "RangeMax", "Ranges", "Intensities" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [START messages]
  /// </summary>
  public sealed partial class Scan : pb::IMessage<Scan> {
    private static readonly pb::MessageParser<Scan> _parser = new pb::MessageParser<Scan>(() => new Scan());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Scan> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ScanOut.ScanReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Scan() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Scan(Scan other) : this() {
      angleMin_ = other.angleMin_;
      angleMax_ = other.angleMax_;
      angleIncrement_ = other.angleIncrement_;
      timeIncrement_ = other.timeIncrement_;
      scanTime_ = other.scanTime_;
      rangeMin_ = other.rangeMin_;
      rangeMax_ = other.rangeMax_;
      ranges_ = other.ranges_.Clone();
      intensities_ = other.intensities_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Scan Clone() {
      return new Scan(this);
    }

    /// <summary>Field number for the "angle_min" field.</summary>
    public const int AngleMinFieldNumber = 1;
    private double angleMin_;
    /// <summary>
    /// start angle of the scan [rad]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double AngleMin {
      get { return angleMin_; }
      set {
        angleMin_ = value;
      }
    }

    /// <summary>Field number for the "angle_max" field.</summary>
    public const int AngleMaxFieldNumber = 2;
    private double angleMax_;
    /// <summary>
    /// end angle of the scan [rad]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double AngleMax {
      get { return angleMax_; }
      set {
        angleMax_ = value;
      }
    }

    /// <summary>Field number for the "angle_increment" field.</summary>
    public const int AngleIncrementFieldNumber = 3;
    private double angleIncrement_;
    /// <summary>
    /// angular distance between measurements [rad]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double AngleIncrement {
      get { return angleIncrement_; }
      set {
        angleIncrement_ = value;
      }
    }

    /// <summary>Field number for the "time_increment" field.</summary>
    public const int TimeIncrementFieldNumber = 4;
    private double timeIncrement_;
    /// <summary>
    /// time between measurements [seconds] - if your scanner
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TimeIncrement {
      get { return timeIncrement_; }
      set {
        timeIncrement_ = value;
      }
    }

    /// <summary>Field number for the "scan_time" field.</summary>
    public const int ScanTimeFieldNumber = 5;
    private double scanTime_;
    /// <summary>
    /// is moving, this will be used in interpolating position
    /// of 3d points
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double ScanTime {
      get { return scanTime_; }
      set {
        scanTime_ = value;
      }
    }

    /// <summary>Field number for the "range_min" field.</summary>
    public const int RangeMinFieldNumber = 6;
    private double rangeMin_;
    /// <summary>
    /// minimum range value [m]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double RangeMin {
      get { return rangeMin_; }
      set {
        rangeMin_ = value;
      }
    }

    /// <summary>Field number for the "range_max" field.</summary>
    public const int RangeMaxFieldNumber = 7;
    private double rangeMax_;
    /// <summary>
    /// maximum range value [m]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double RangeMax {
      get { return rangeMax_; }
      set {
        rangeMax_ = value;
      }
    }

    /// <summary>Field number for the "ranges" field.</summary>
    public const int RangesFieldNumber = 8;
    private static readonly pb::FieldCodec<double> _repeated_ranges_codec
        = pb::FieldCodec.ForDouble(66);
    private readonly pbc::RepeatedField<double> ranges_ = new pbc::RepeatedField<double>();
    /// <summary>
    /// range data [m] (Note: values &lt; range_min or > range_max should be discarded)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<double> Ranges {
      get { return ranges_; }
    }

    /// <summary>Field number for the "intensities" field.</summary>
    public const int IntensitiesFieldNumber = 9;
    private static readonly pb::FieldCodec<double> _repeated_intensities_codec
        = pb::FieldCodec.ForDouble(74);
    private readonly pbc::RepeatedField<double> intensities_ = new pbc::RepeatedField<double>();
    /// <summary>
    /// intensity data [device-specific units].  If your
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<double> Intensities {
      get { return intensities_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Scan);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Scan other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AngleMin, other.AngleMin)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AngleMax, other.AngleMax)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AngleIncrement, other.AngleIncrement)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TimeIncrement, other.TimeIncrement)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ScanTime, other.ScanTime)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(RangeMin, other.RangeMin)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(RangeMax, other.RangeMax)) return false;
      if(!ranges_.Equals(other.ranges_)) return false;
      if(!intensities_.Equals(other.intensities_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AngleMin != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AngleMin);
      if (AngleMax != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AngleMax);
      if (AngleIncrement != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AngleIncrement);
      if (TimeIncrement != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TimeIncrement);
      if (ScanTime != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ScanTime);
      if (RangeMin != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(RangeMin);
      if (RangeMax != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(RangeMax);
      hash ^= ranges_.GetHashCode();
      hash ^= intensities_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AngleMin != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(AngleMin);
      }
      if (AngleMax != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(AngleMax);
      }
      if (AngleIncrement != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(AngleIncrement);
      }
      if (TimeIncrement != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(TimeIncrement);
      }
      if (ScanTime != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(ScanTime);
      }
      if (RangeMin != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(RangeMin);
      }
      if (RangeMax != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(RangeMax);
      }
      ranges_.WriteTo(output, _repeated_ranges_codec);
      intensities_.WriteTo(output, _repeated_intensities_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AngleMin != 0D) {
        size += 1 + 8;
      }
      if (AngleMax != 0D) {
        size += 1 + 8;
      }
      if (AngleIncrement != 0D) {
        size += 1 + 8;
      }
      if (TimeIncrement != 0D) {
        size += 1 + 8;
      }
      if (ScanTime != 0D) {
        size += 1 + 8;
      }
      if (RangeMin != 0D) {
        size += 1 + 8;
      }
      if (RangeMax != 0D) {
        size += 1 + 8;
      }
      size += ranges_.CalculateSize(_repeated_ranges_codec);
      size += intensities_.CalculateSize(_repeated_intensities_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Scan other) {
      if (other == null) {
        return;
      }
      if (other.AngleMin != 0D) {
        AngleMin = other.AngleMin;
      }
      if (other.AngleMax != 0D) {
        AngleMax = other.AngleMax;
      }
      if (other.AngleIncrement != 0D) {
        AngleIncrement = other.AngleIncrement;
      }
      if (other.TimeIncrement != 0D) {
        TimeIncrement = other.TimeIncrement;
      }
      if (other.ScanTime != 0D) {
        ScanTime = other.ScanTime;
      }
      if (other.RangeMin != 0D) {
        RangeMin = other.RangeMin;
      }
      if (other.RangeMax != 0D) {
        RangeMax = other.RangeMax;
      }
      ranges_.Add(other.ranges_);
      intensities_.Add(other.intensities_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            AngleMin = input.ReadDouble();
            break;
          }
          case 17: {
            AngleMax = input.ReadDouble();
            break;
          }
          case 25: {
            AngleIncrement = input.ReadDouble();
            break;
          }
          case 33: {
            TimeIncrement = input.ReadDouble();
            break;
          }
          case 41: {
            ScanTime = input.ReadDouble();
            break;
          }
          case 49: {
            RangeMin = input.ReadDouble();
            break;
          }
          case 57: {
            RangeMax = input.ReadDouble();
            break;
          }
          case 66:
          case 65: {
            ranges_.AddEntriesFrom(input, _repeated_ranges_codec);
            break;
          }
          case 74:
          case 73: {
            intensities_.AddEntriesFrom(input, _repeated_intensities_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
